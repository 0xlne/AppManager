// SPDX-License-Identifier: GPL-3.0-or-later

package io.github.muntashirakon.io;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.j256.simplemagic.ContentInfo;
import com.j256.simplemagic.ContentInfoUtil;

import java.io.InputStream;

import io.github.muntashirakon.AppManager.fm.ContentType2;
import io.github.muntashirakon.AppManager.logs.Log;

public class PathContentInfo {
    public static final String TAG = PathContentInfo.class.getSimpleName();

    private static ContentInfoUtil contentInfoUtil;

    @NonNull
    public static PathContentInfo fromPath(@NonNull Path path) {
        if (path.isDirectory()) {
            return DIRECTORY;
        }
        if (contentInfoUtil == null) {
            contentInfoUtil = new ContentInfoUtil();
        }
        String ext = path.getExtension();
        ContentInfo extInfo = ext != null ? ContentInfoUtil.findExtensionMatch(ext) : null;
        ContentType2 extType2 = ext != null ? ContentType2.fromFileExtension(ext) : null;
        try (InputStream is = path.openInputStream()) {
            ContentInfo contentInfo = contentInfoUtil.findMatch(is);
            if (contentInfo != null) {
                // FIXME: 20/11/22 This will not work for invalid extensions. A better option is to use magic-mime-db
                //  instead which is currently a WIP.
                if (extInfo != null) {
                    return new PathContentInfo(extInfo.getName(), contentInfo.getMessage(), extInfo.getMimeType(),
                            extInfo.getFileExtensions(), contentInfo.isPartial());
                }
                if (extType2 != null) {
                    return new PathContentInfo(extType2.getSimpleName(), contentInfo.getMessage(),
                            extType2.getMimeType(), extType2.getFileExtensions(), contentInfo.isPartial());
                }
                return fromContentInfo(contentInfo);
            }
        } catch (Throwable e) {
            Log.e(TAG, "Could not load MIME type for path " + path, e);
        }
        if (extInfo != null) {
            return fromContentInfo(extInfo);
        }
        if (extType2 != null) {
            return fromContentType2(extType2);
        }
        return fromContentType2(ContentType2.OTHER);
    }

    @NonNull
    public static PathContentInfo fromContentInfo(@NonNull ContentInfo contentInfo) {
        return new PathContentInfo(contentInfo.getName(), contentInfo.getMessage(), contentInfo.getMimeType(),
                contentInfo.getFileExtensions(), contentInfo.isPartial());
    }

    @NonNull
    public static PathContentInfo fromContentType2(@NonNull ContentType2 contentType2) {
        return new PathContentInfo(contentType2.getSimpleName(), null, contentType2.getMimeType(),
                contentType2.getFileExtensions(), false);
    }

    public static final PathContentInfo DIRECTORY = new PathContentInfo("Directory", null, "resource/folder", null, false);

    @NonNull
    private final String mName;
    @Nullable
    private final String mMessage;
    @Nullable
    private final String mMimeType;
    @Nullable
    private final String[] mFileExtensions;
    private final boolean mPartial;

    public PathContentInfo(@NonNull String name, @Nullable String message, @Nullable String mimeType,
                           @Nullable String[] fileExtensions, boolean partial) {
        mName = name;
        mMessage = message;
        mMimeType = mimeType;
        mFileExtensions = fileExtensions;
        mPartial = partial;
    }

    /**
     * Returns the short name of the content either from the content-type or extracted from the message. If the
     * content-type is known then this is a specific name string. Otherwise, this is usually the first word of the
     * message generated by the magic file.
     */
    @NonNull
    public String getName() {
        return mName;
    }

    /**
     * Returns the mime-type or null if none.
     */
    @Nullable
    public String getMimeType() {
        return mMimeType;
    }

    /**
     * Returns the full message as generated by the magic matching code or null if none. This should be similar to the
     * output from the Unix file(1) command.
     */
    @Nullable
    public String getMessage() {
        return mMessage;
    }

    /**
     * Returns an array of associated file-extensions or null if none.
     */
    @Nullable
    public String[] getFileExtensions() {
        return mFileExtensions;
    }

    /**
     * Whether this was a partial match. For some types, there is a main matching pattern and then more
     * specific patterns which detect additional features of the type. A partial match means that none of the more
     * specific patterns fully matched the content. It's probably still of the type but just not a variant that the
     * entries from the magic file(s) know about.
     */
    public boolean isPartial() {
        return mPartial;
    }
}
