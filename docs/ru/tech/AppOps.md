---
prev: ./
sidebarDepth: 2
---

# Операции приложения

*Перейдите к [похожей проблеме](https://github.com/MuntashirAkon/AppManager/issues/17) для обсуждения.*

::: details Таблица содержания
[[toc]]
:::

## Фоновый режим
**Операции приложения** используются системой Android (начиная с Android 4.3) для управления разрешениями приложений. Пользователь *может* контролировать некоторые разрешения, но только те разрешения, которые считаются опасными (однако Google считает, что знание вашего номера телефона не опасно). Итак, кажется, что операции приложений – это то, что нам нужно, если мы хотим устанавливать такие приложения, как Facebook, Facebook Messenger (который буквально записывает все), и все еще хотим *немного* приватности и/или безопасности. Хотя некоторые функции приложений были доступны в настройках, а затем в скрытых настройках в более старых версиях Android, в новых версиях Android они полностью скрыты и продолжают оставаться скрытыми. Теперь любое приложение с разрешением **android.Manifest.permission.GET_APP_OPS_STATS** может получать информацию об операциях приложения для других приложений, но это разрешение скрыто от пользователей и может быть включено только с помощью ADB или root. Тем не менее, приложение с этим разрешением не может предоставлять или отзывать разрешения (фактически режим операции) для приложений, отличных от себя (конечно, с ограниченными возможностями). Для изменения операции другого приложения, приложению необходимо разрешение **android.Manifest.permission.UPDATE_APP_OPS_STATS**, которое недоступно через команду _pm_. Таким образом, вы не можете предоставить его через root или ADB, разрешение предоставляется только системным приложениям. Очень мало приложений, которые поддерживают отключение разрешений через операции приложения. Насколько мне известно, лучшее среди них это [AppOpsX][1]. Основное (видимое) различие между моим приложением (App Manager) и этим приложением заключается в том, что последнее также предоставляет вам возможность отменять разрешения в интернете (путем написания таблиц IP). Другое отличие состоит в том, что автор использовал скрытый API для доступа/предоставления/отзыва операций, тогда как я использовал инструмент командой строки [_appops_](#интерфейс-командной-строки-appops) для этого. Я сделал это из-за предела [рефлексии][2]< недавно введенной в Android, которая сделала многие скрытые API непригодными для использования (есть некоторые хаки, но они могут не работать после выхода финальной версии Android R). Одна из важнейших проблем, с которыми я столкнулся при разработке API раздела операций приложений, – это отсутствие документации на английском языке.

## Знакомство с операциями приложений

<img :src="$withBase('/assets/how_app_ops_work.png')" alt="Как работают операции приложений" />

Фигура (взята из [этой статьи][3]) выше описывает процесс изменения и обработки разрешения. [**AppOpsManager**](#AppOpsManager) можно использовать для управления разрешениями в приложении "Настройки". **AppOpsManager** также полезен при определении того, предоставлено ли приложению определенное разрешение (или операция). Большинство методов **AppOpsManager** доступны для пользовательских приложений, но в отличие от системных приложений, их можно использовать только для проверки разрешений для любого приложения или для самого приложения, а также для запуска или завершения определенных операций. Более того, не все операции фактически доступны из этого класса Java. **Диспетчер операций приложений** содержит все необходимые константы, такие как [_OP\_*_](#константы-op), `OPSTR_*`, [_MODE\_*_](#константы-mode), которые описывают код операции, строку операции и режим работы соответственно. Он также содержит необходимые структуры данных, такие как [**PackageOps**](#операции-пакетов) и **OpEntry**. **PackageOps** держит **OpEntry** длч пакета, и **OpEntry**, как следует из названия, описывает каждую операцию. Под влиянием, **AppOpsManager** вызывает службу **AppOpsService** выполнять любую реальную работу.

Служба [**AppOpService**][5] полностью скрыта для пользовательских приложений, но доступна для системных. Как видно на рисунке, это класс, который выполняет фактическое управление. Он содержит такие структуры данных, как **операции** для хранения базовой информации о пакете и **операцию** что похоже на **OpEntry** из **AppOpsManager**. Он также имеет **оболочку** которая на самом деле является исходным кодом инструмента командной строки_appops_. Он записывает или считывает конфигурации из [/data/system/appops.xml](#appops-xml). Системные службы вызывают **AppOpsService**, чтобы узнать, какие приложения разрешены, а какие не разрешены, а **AppOpsService** определяет эти разрешения путем анализа `/data/system/appops.xml`. Если пользовательские значения не заданы в _appops.xml_, он возвращает режим по умолчанию, доступный в **AppOpsManager**.


## AppOpsManager
[AppOpsManager][4], он же «Диспетчер операций приложений». Он содержит в себе различные константы и классы для редактирования операций приложений. Официальную документацию по нему можно найти [здесь][11].

### Константы OP_*
`OP_*` – целые константы, начинающиеся с цифры `0`. Константа `OP_NONE` указывает, что операции не определены, тогда как `_NUM_OP` обозначает количество операций, определенных в префиксе `OP_*`.  Обозначает каждую операцию. Но эти операции не обязательно должны быть уникальными. Фактически, есть много операций, которые на самом деле являются одной операцией, обозначенной несколькими константами `OP_*` (возможно, для будущего использования). Надстройки Android могут определять операции в зависимости от своих требований. MIUI – одна из известных надстроек, которая умеет это делать.

_Краткий обзор `OP_*`:_
``` java{1,10}
public static final int OP_NONE = -1;
public static final int OP_COARSE_LOCATION = 0;
public static final int OP_FINE_LOCATION = 1;
public static final int OP_GPS = 2;
public static final int OP_VIBRATE = 3;
...
public static final int OP_READ_DEVICE_IDENTIFIERS = 89;
public static final int OP_ACCESS_MEDIA_LOCATION = 90;
public static final int OP_ACTIVATE_PLATFORM_VPN = 91;
public static final int _NUM_OP = 92;
```

Уникальность операции определяется переменной [`sOpToSwitch`][7]. Она соотносит каждую операцию с другой операцией или с самой собой (если это уникальная операция). Например, `OP_FINE_LOCATION` и `OP_GPS` сопоставлены с `OP_COARSE_LOCATION`.

Каждая операция имеет личное имя, которое описывается переменной [`sOpNames`][10]. Эти имена обычно совпадают с именами констант без префикса `OP_`. Некоторые операции также имеют публичные имена, которые описываются описываются переменной `sOpToString`. Например, `OP_COARSE_LOCATION` имеет публичное имя **android:coarse_location**.

По мере постепенного процесса перемещения разрешений в операции приложений уже существует множество разрешений, определенных для некоторых операций. Эти разрешения сопоставляются со значением [`sOpPerms`][8]. Например, разрешение **android.Manifest.permission.ACCESS_COARSE_LOCATION** сопоставлено с `OP_COARSE_LOCATION`. Некоторые операции могут не иметь соответствующих разрешений, которые имеют значения `null`.

Как описано в предыдущем разделе, операции, настроенные для приложения, хранятся в [/data/system/appops.xml](#appops-xml). Если операция не настроена, то будет ли система разрешать эту операцию, определяется из значения [`sOpDefaultMode`][9]. В нем отображается _режим по умолчанию_ для каждой операции.

### Константы MODE_*
Константы `MODE_*`, а также целочисленные константы, начинаются с цифры `0`. Эти константы назначаются каждой операции, описывающей, авторизовано ли приложение для выполнения этой операции. Эти режимы обычно имеют связанные имена, такие как **allow** для `MODE_ALLOWED`, **ignore** для `MODE_IGNORED`, **deny** для `MODE_ERRORED` (довольно мизономер), **default** для `MODE_DEFAULT` и **foreground** для `MODE_FOREGROUND`.

_Стандартные режимы:_
``` java
/**
 * данному вызывающему абоненту разрешено выполнять данную операцию.
 */
public static final int MODE_ALLOWED = 0;
/**
 * данному звонящему не разрешено выполнять данную операцию, и эта попытка должна
 * <em>молча потерпеть неудачу</em> (это не должно привести к сбою приложения).
 */
public static final int MODE_IGNORED = 1;
/**
 * данному звонящему не разрешено выполнять данную операцию, и эта попытка должна
 * вызвать фатальную ошибку, обычно это {@link SecurityException}.
 */
public static final int MODE_ERRORED = 1 << 1;  // 2
/**
 * данный звонящий должен использовать проверку безопасности по умолчанию. Этот режим обычно не используется
 */
public static final int MODE_DEFAULT = 3;
/**
 * Специальный режим, который означает «разрешить, только когда приложение используется».
 */
public static final int MODE_FOREGROUND = 1 << 2;
```

Помимо этих режимов по умолчанию, поставщики могут устанавливать собственные режимы, такие как `MODE_ASK` (с именем **ask**), который активно используется в MIUI. MIUI также использует некоторые другие режимы без каких-либо связанных с ними имен.


### Операции пакетов
**AppOpsManager.PackageOps** – это структура данных для хранения всех **OpEntry** пакета. Проще говоря, она хранит все настроенные операции для пакета.

``` java
public static class PackageOps implements Parcelable {
  private final String mPackageName;
  private final int mUid;
  private final List<OpEntry> mEntries;
  ...
}
```
Как видно выше, в нем хранятся все **OpEntry** пакета, а также соответствующее имя пакета и его идентификатор пользователя ядра.


### OpEntry
**AppOpsManager.OpEntry** – это структура данных, в которой хранится одна операция для любого пакета.

``` java
public static final class OpEntry implements Parcelable {
    private final int mOp;
    private final boolean mRunning;
    private final @Mode int mMode;
    private final @Nullable LongSparseLongArray mAccessTimes;
    private final @Nullable LongSparseLongArray mRejectTimes;
    private final @Nullable LongSparseLongArray mDurations;
    private final @Nullable LongSparseLongArray mProxyUids;
    private final @Nullable LongSparseArray<String> mProxyPackageNames;
    ...
}
```
Здесь:
- `mOp`: обозначает одну из констант [`OP_*`](#константы-op).
- `mRunning`: выполняются ли операции (т. е, операция началась, но еще не завершена). Не все операции можно запустить или завершить таким образом.
- `mMOde`: одна из констант [`MODE_*`](#константы-mode).
- `mAccessTimes`: хранит все доступные времена принятия
- `mRejectTimes`: хранит все доступные времена отклонения
- `mDurations`: все доступные длительности доступа, выполняемые с помощью `mRunning` сообщат вам, как долго приложение выполняет определенную операцию.
- `mProxyUids`: документация не найдена
- `mProxyPackageNames`: документация не найдена

### Использование
Список задач

## Служба AppOpsService
Список задач

## appops.xml

`appops.xml` имеет следующий формат: (этот шаблон создан мной и никоим образом не претендует на звание идеального образца, может содержать проблемы с совместимостью).

```dtd
<!DOCTYPE app-ops [

<!ELEMENT app-ops (uid|pkg)*>
<!ATTLIST app-ops v CDATA #IMPLIED>

<!ELEMENT uid (op)*>
<!ATTLIST uid n CDATA #REQUIRED>

<!ELEMENT pkg (uid)*>
<!ATTLIST pkg n CDATA #REQUIRED>

<!ELEMENT uid (op)*>
<!ATTLIST uid
n CDATA #REQUIRED
p CDATA #IMPLIED>

<!ELEMENT op (st)*>
<!ATTLIST op
n CDATA #REQUIRED
m CDATA #REQUIRED>

<!ELEMENT st EMPTY>
<!ATTLIST st
n CDATA #REQUIRED
t CDATA #IMPLIED
r CDATA #IMPLIED
d CDATA #IMPLIED
pp CDATA #IMPLIED
pu CDATA #IMPLIED>

]>
```

Приведенные ниже инструкции следуют точному порядку, указанному выше:
* `app-ops`: корневой элемент. Оно может содержать любое количество `pkg` или пакетов `uid`
  - `v`: (опционально, целое число) номер версии (по умолчанию: `NO_VERSION` или `-1`)
* `pkg`: информация о пакете магазинов. Оно может содержать любое количество `uid`
  - `n`: (обязательно, строка) название пакета
* Пакет `uid`: хранит пакет или информацию о пакетах
  - `n`: (обязательно, целое число) идентификатор пользователя
* `uid`: идентификатор пользователя пакета Оно может содержать любое количество `операций`
  - `n`: (обязательно, целое число) идентификатор пользователя
  - `p`: (необязательно, логический) указывает, является ли приложение приватным или системным
* `op`: операция, которая может содержать `st` или вообще ничего
  - `n`: (обязательно, целое число) имя операции в целом числе AppOpsManager.OP_*
  - `m`: (обязательно, целое число) режим операции AppOpsManager.MODE_*
* `st`: состояние операции: выполняется ли операция, выполняется ли доступ, отклонено или запущено (недоступно в старых версиях)
  - `n`: (обязательно, длинное число) ключ, содержащий флаги и uid
  - `t`: (опционально, длинное число) время доступа (по умолчанию: `0`)
  - `r`: (опционально, длинное число) время отклонения (по умолчанию: `0`)
  - `d`: (опционально, длинное число) длительность доступа (по умолчанию: `0`)
  - `pp`: (опционально, строка) имя пакета прокси
  - `pu`: (опционально, целое число) uid пакета прокси

Это определение можно найти на странице [**AppOpsService**][5].

## Интерфейс командной строки appops
`appops` или `cmd appops` (в последних версиях) могут быть доступны через ADB или root. Это более простой способ получить или обновить любую операцию для пакета (при условии, что имя пакета известно). Страница справки по этой команде не требует пояснений:

```
Команды службы AppOps (appops):
help
  Напишите этот текст для получения справки.
start [--user <USER_ID>] <PACKAGE | UID> <OP> 
  Запускает заданную операцию для определенного приложения.
stop [--user <USER_ID>] <PACKAGE | UID> <OP> 
  Останавливает заданную операцию для определенного приложения.
set [--user <USER_ID>] <[--uid] PACKAGE | UID> <OP> <MODE>
  Устанавливает режим для конкретного приложения и операции.
get [--user <USER_ID>] <PACKAGE | UID> [<OP>]
  Возвращает режим для конкретного приложения и дополнительной операции.
query-op [--user <USER_ID>] <OP> [<MODE>]
  Вывод всех пакетов, которые в данный момент имеют данную операцию в данном режиме.
reset [--user <USER_ID>] [<PACKAGE>]
  Сброс данного приложение или все приложения в режимы по умолчанию.
write-settings
  Немедленная запись ожидающих изменений в хранилище.
read-settings
  Чтение последних записанных настроек, заменив текущее состояние в ОЗУ.
опции:
  <PACKAGE> имя пакета Android или его UID, если перед ним стоит префикс --uid
  <OP>      операция AppOps.
  <MODE>    одно из разрешить, игнорировать, запретить или по умолчанию
  <USER_ID> идентификатор пользователя, под которым установлен пакет. Если --user не указан
            , предполагается текущий пользователь.
```

[1]: https://github.com/8enet/AppOpsX
[2]: https://stackoverflow.com/questions/37628
[3]: https://translate.googleusercontent.com/translate_c?depth=2&pto=aue&rurl=translate.google.com&sl=auto&sp=nmt4&tl=en&u=https://www.cnblogs.com/0616--ataozhijia/p/5009718.html&usg=ALkJrhgSo4IcKp2cXJlqttXuiRJZGa_jnw
[5]: https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/appop/AppOpsService.java
[4]: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/AppOpsManager.java
[11]: https://developer.android.com/reference/android/app/AppOpsManager
[7]: https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/AppOpsManager.java;drc=44cbdec292c6b234d94aae59257721cf499989ba;bpv=1;bpt=1;l=211?q=AppOpsManager&ss=android%2Fplatform%2Fsuperproject&gsn=sOpToSwitch&gs=kythe%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Fsuperproject%3Flang%3Djava%3Fpath%3Dandroid.app.AppOpsManager%238ffb80c9b09fce58d7fe1a0af7d50fd025765d8f41e838fa3bc2754dd99d9c48
[8]: https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/AppOpsManager.java;drc=44cbdec292c6b234d94aae59257721cf499989ba;bpv=1;bpt=1;l=361?gsn=sOpPerms&gs=kythe%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Fsuperproject%3Flang%3Djava%3Fpath%3Dandroid.app.AppOpsManager%23230bc1462b07a3c1575477761782a9d3537d75b4ea0a16748082c74f50bc2814
[9]: https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/AppOpsManager.java;drc=44cbdec292c6b234d94aae59257721cf499989ba;bpv=1;bpt=1;l=410?gsn=sOpDefaultMode&gs=kythe%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Fsuperproject%3Flang%3Djava%3Fpath%3Dandroid.app.AppOpsManager%23a8c8e4e247453a8ce329b2c1130f9c7a7f91e2b97d159c3e18c768b4d42f1b75
[10]: https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/AppOpsManager.java;drc=44cbdec292c6b234d94aae59257721cf499989ba;bpv=1;bpt=1;l=311?gsn=sOpNames&gs=kythe%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Fsuperproject%3Flang%3Djava%3Fpath%3Dandroid.app.AppOpsManager%234f77b221ad3e5d9212e217eadec0b78cd35717a3bf2d0f2bc642dea241e02d72
